{"ast":null,"code":"import { appendErrors as r } from \"react-hook-form\";\nimport { validateFieldsNatively as e, toNestError as o } from \"@hookform/resolvers\";\n\nvar n = function (e, o) {\n  for (var n = {}; e.length;) {\n    var s = e[0],\n        t = s.code,\n        i = s.message,\n        a = s.path.join(\".\");\n    if (!n[a]) if (\"unionErrors\" in s) {\n      var u = s.unionErrors[0].errors[0];\n      n[a] = {\n        message: u.message,\n        type: u.code\n      };\n    } else n[a] = {\n      message: i,\n      type: t\n    };\n\n    if (\"unionErrors\" in s && s.unionErrors.forEach(function (r) {\n      return r.errors.forEach(function (r) {\n        return e.push(r);\n      });\n    }), o) {\n      var c = n[a].types,\n          f = c && c[s.code];\n      n[a] = r(a, o, n, t, f ? [].concat(f, s.message) : s.message);\n    }\n\n    e.shift();\n  }\n\n  return n;\n},\n    s = function (r, s, t) {\n  return void 0 === t && (t = {}), function (i, a, u) {\n    try {\n      return Promise.resolve(function (o, n) {\n        try {\n          var a = Promise.resolve(r[\"sync\" === t.mode ? \"parse\" : \"parseAsync\"](i, s)).then(function (r) {\n            return u.shouldUseNativeValidation && e({}, u), {\n              errors: {},\n              values: t.rawValues ? i : r\n            };\n          });\n        } catch (r) {\n          return n(r);\n        }\n\n        return a && a.then ? a.then(void 0, n) : a;\n      }(0, function (r) {\n        return {\n          values: {},\n          errors: r.isEmpty ? {} : o(n(r.errors, !u.shouldUseNativeValidation && \"all\" === u.criteriaMode), u)\n        };\n      }));\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n};\n\nexport { s as zodResolver };","map":{"version":3,"mappings":";;;AASA,IAAMA,IAAmB,UACvBC,CADuB,EAEvBC,CAFuB,EAEvBA;AAGA,OADA,IAAMC,IAAqC,EAC3C,EAAOF,EAAUG,MAAjB,GAA0B;AACxB,QAAMC,IAAQJ,EAAU,CAAVA,CAAd;AAAA,QACQK,IAAwBD,EAAxBC,IADR;AAAA,QACcC,IAAkBF,EAAlBE,OADd;AAAA,QAEMC,IAD0BH,EAATI,IAASJ,CACbK,IADaL,CACR,GADQA,CADhC;AAIA,SAAKF,EAAOK,CAAPL,CAAL,EACE,IAAI,iBAAiBE,CAArB,EAA4B;AAC1B,UAAMM,IAAaN,EAAMO,WAANP,CAAkB,CAAlBA,EAAqBF,MAArBE,CAA4B,CAA5BA,CAAnB;AAEAF,QAAOK,CAAPL,IAAgB;AACdI,iBAASI,EAAWJ,OADN;AAEdM,cAAMF,EAAWL;AAFH,OAAhBH;AAEmBG,KALrB,MAQEH,EAAOK,CAAPL,IAAgB;AAAEI,gBAAF;AAAWM,YAAMP;AAAjB,KAAhBH;;AAUJ,QANI,iBAAiBE,CAAjB,IACFA,EAAMO,WAANP,CAAkBS,OAAlBT,CAA0B,UAACM,CAAD,EAACA;AAAAA,aACzBA,EAAWR,MAAXQ,CAAkBG,OAAlBH,CAA0B,UAACI,CAAD,EAACA;AAAAA,eAAMd,EAAUe,IAAVf,CAAec,CAAfd,CAANc;AAAqBA,OAAhDJ,CADyBA;AACuBI,KADlDV,CADE,EAMAH,CAAJ,EAA8B;AAC5B,UAAMe,IAAQd,EAAOK,CAAPL,EAAcc,KAA5B;AAAA,UACMC,IAAWD,KAASA,EAAMZ,EAAMC,IAAZW,CAD1B;AAGAd,QAAOK,CAAPL,IAAgBgB,EACdX,CADcW,EAEdjB,CAFciB,EAGdhB,CAHcgB,EAIdb,CAJca,EAKdD,IACK,GAAgBE,MAAhB,CAAuBF,CAAvB,EAA6Cb,EAAME,OAAnD,CADLW,GAEIb,EAAME,OAPIY,CAAhBhB;AAWFF;;AAAAA,MAAUoB,KAAVpB;AAGF;;AAAA,SAAOE,CAAP;AAAOA,CA/CT;AAAA,IAkDamB,IACX,UAACC,CAAD,EAASC,CAAT,EAAwBC,CAAxB,EAAwBA;AAAAA,8BAAkB,EAAlBA,GAAkB,UACjCC,CADiC,EACzBC,CADyB,EACtBC,CADsB,EACtBA;AAAAA;AAAAA;AAAAA;AAAAA,kCAEKL,EACQ,WAAzBE,EAAgBI,IAAS,GAAS,OAAT,GAAmB,YAD3BN,EAEjBG,CAFiBH,EAETC,CAFSD,CAFLK,EAIJJ,IAJII,CAIJJ,UAFJM,CAEIN,EAFJM;AAMN,mBAFAF,EAAQG,yBAARH,IAAqCI,EAAuB,EAAvBA,EAA2BJ,CAA3BI,CAArCJ,EAEO;AACLzB,sBAAQ,EADH;AAELuB,sBAAQD,EAAgBQ,SAAhBR,GAA4BC,CAA5BD,GAAqCK;AAFxC,aAAP;AAE+CA,WAVjCF;AAUiCE,SAVjCF,CAUiCE;AAAAA;AAAAA;;AAAAA;AAAAA,OAVjCF,CAUiCE,CAVjCF,EAUiCE,UAExCzB,CAFwCyB,EAExCzB;AACP,eAAO;AACLqB,kBAAQ,EADH;AAELvB,kBAAQE,EAAM6B,OAAN7B,GACJ,EADIA,GAEJ8B,EACAnC,EACEK,EAAMF,MADRH,EACQG,CACLyB,EAAQG,yBADH5B,IAEmB,UAAzByB,EAAQQ,YAHVpC,CADAmC,EAMAP,CANAO;AAJC,SAAP;AAUMP,OAvBQA;AADpB,KACoBA,CADpB;AAAA;AAAA;AAAA,GAAwBH;AAAxB,CAnDF;;AAmDE","names":["parseErrorSchema","zodErrors","validateAllFieldCriteria","errors","length","error","code","message","_path","path","join","unionError","unionErrors","type","forEach","e","push","types","messages","appendErrors","concat","shift","zodResolver","schema","schemaOptions","resolverOptions","values","_","options","mode","data","shouldUseNativeValidation","validateFieldsNatively","rawValues","isEmpty","toNestError","criteriaMode"],"sources":["E:\\Projects\\Rebartek\\cms.webui\\node_modules\\@hookform\\resolvers\\zod\\src\\zod.ts"],"sourcesContent":["import {\n  appendErrors,\n  FieldError,\n  FieldErrors,\n} from 'react-hook-form';\nimport { z } from 'zod';\nimport { toNestError, validateFieldsNatively } from '@hookform/resolvers';\nimport type { Resolver } from './types';\n\nconst parseErrorSchema = (\n  zodErrors: z.ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) => {\n  const errors: Record<string, FieldError> = {};\n  for (; zodErrors.length;) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if ('unionErrors' in error) {\n        const unionError = error.unionErrors[0].errors[0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if ('unionErrors' in error) {\n      error.unionErrors.forEach((unionError) =>\n        unionError.errors.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n};\n\nexport const zodResolver: Resolver =\n  (schema, schemaOptions, resolverOptions = {}) =>\n    async (values, _, options) => {\n      try {\n        const data = await schema[\n          resolverOptions.mode === 'sync' ? 'parse' : 'parseAsync'\n        ](values, schemaOptions);\n\n        options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n        return {\n          errors: {} as FieldErrors,\n          values: resolverOptions.rawValues ? values : data,\n        };\n      } catch (error: any) {\n        return {\n          values: {},\n          errors: error.isEmpty\n            ? {}\n            : toNestError(\n              parseErrorSchema(\n                error.errors,\n                !options.shouldUseNativeValidation &&\n                options.criteriaMode === 'all',\n              ),\n              options,\n            ),\n        };\n      }\n    };\n"]},"metadata":{},"sourceType":"module"}